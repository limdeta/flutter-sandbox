@startuml

' UserTrack
class UserTrack {
  +int id
  +int userId
  +int? routeId
  +DateTime startTime
  +DateTime? endTime
  +List<TrackPoint> points
  +double totalDistanceMeters
  +int movingTimeSeconds
  +int totalTimeSeconds
  +double averageSpeedKmh
  +double maxSpeedKmh
  +TrackStatus status
  +Map<String, dynamic>? metadata
  +bool get isActive()
  +bool get isCompleted()
  +bool get isPaused()
  +TrackPoint? get lastPoint()
  +TrackPoint? get firstPoint()
  +double get totalDistanceKm()
  +double get movingTimeMinutes()
  +double get totalTimeMinutes()
  +UserTrack addPoint(TrackPoint point)
  +UserTrack addPoints(List<TrackPoint> newPoints)
  +UserTrack complete(DateTime? endTime)
  +UserTrack pause()
  +UserTrack resume()
  +UserTrack copyWith(...)
  +String toString()
  +factory create(...)
}

class TrackPoint {
  +double latitude
  +double longitude
  +DateTime timestamp
  +double? accuracy
  +double? altitude
  +double? altitudeAccuracy
  +double? speedKmh
  +double? bearing
  +double? distanceFromPrevious
  +int? timeFromPrevious
  +Map<String, dynamic>? metadata
  +bool get isValid()
  +bool get hasGoodAccuracy()
  +bool get isMoving()
  +double distanceTo(TrackPoint other)
  +double bearingTo(TrackPoint other)
  +TrackPoint withPreviousPointData(TrackPoint? previousPoint)
  +bool isSignificantlyDifferentFrom(TrackPoint other, ...)
  +TrackPoint copyWith(...)
  +String toString()
  +factory fromGPS(...)
  +factory test(...)
}

enum TrackStatus {
  active
  paused
  completed
  cancelled
}

abstract class IUserTrackRepository {
  +Future<UserTrack> saveTrack(UserTrack track)
  +Future<UserTrack> updateTrack(UserTrack track)
  +Future<UserTrack?> getTrackById(int id)
  +Future<List<UserTrack>> getTracksByUserId(int userId)
  +Future<List<UserTrack>> getTracksByUserIdAndDateRange(...)
  +Future<List<UserTrack>> getTracksByRouteId(int routeId)
  +Future<UserTrack?> getActiveTrackByUserId(int userId)
  +Future<bool> deleteTrack(int id)
  +Future<void> saveTrackPoints(int trackId, List<TrackPoint> points)
  +Future<List<TrackPoint>> getTrackPoints(int trackId)
  +Future<List<TrackPoint>> getTrackPointsByDateRange(...)
  +Future<UserTrackStatistics> getUserTrackStatistics(int userId)
  +Future<UserTrackStatistics> getUserTrackStatisticsByDateRange(...)
  +Future<int> cleanupOldTracks(...)
}

class UserTrackStatistics {
  +int totalTracks
  +double totalDistanceMeters
  +int totalMovingTimeSeconds
  +int totalTimeSeconds
  +double averageSpeedKmh
  +double maxSpeedKmh
  +int activeTracks
  +int completedTracks
  +DateTime? firstTrackDate
  +DateTime? lastTrackDate
  +double get totalDistanceKm()
  +double get totalMovingTimeHours()
  +double get totalTimeHours()
  +String toString()
}

class LocationTrackingService {
  +Stream<TrackPoint> get trackPointStream()
  +Stream<UserTrack> get trackUpdateStream()
  +UserTrack? get currentTrack()
  +bool get isTracking()
  +Future<bool> get hasLocationPermissions()
  +Future<bool> requestLocationPermissions()
  +Future<bool> startTracking(...)
  +Future<void> pauseTracking()
  +Future<bool> resumeTracking()
  +Future<UserTrack?> stopTracking()
  +Future<void> dispose()
}

class LocationTrackingSettings {
  +LocationAccuracy accuracy
  +double minDistanceMeters
  +int minTimeSeconds
  +double maxAccuracyMeters
  +Duration updateInterval
  +int bufferSize
  +int stationaryThreshold
  +factory highAccuracy()
  +factory batteryOptimized()
}

class RealtimeTrackingService {
  +Stream<UserTrack> get trackUpdateStream()
  +Stream<ConnectionEvent> get connectionStream()
  +Stream<TrackPointEvent> get trackPointStream()
  +UserTrack? get currentActiveTrack()
  +DateTime? get lastUpdateTime()
  +bool get isConnected()
  +Future<void> startTrackingUser(int userId)
  +Future<void> stopTracking()
  +Future<void> forceRefresh(int userId)
  +Future<void> addTrackPoint(TrackPoint point)
  +Future<void> updateTrackStatus(TrackStatus newStatus)
  +void dispose()
}

class ConnectionEvent {
  +ConnectionEventType type
  +String? message
  +TrackStatus? trackStatus
  +factory connected()
  +factory connectionLost()
  +factory reconnected()
  +factory error(String message)
  +factory noActiveTrack()
  +factory trackEnded()
  +factory statusChanged(TrackStatus status)
}

enum ConnectionEventType {
  connected
  connectionLost
  reconnected
  error
  noActiveTrack
  trackEnded
  statusChanged
}

class TrackPointEvent {
  +TrackPointEventType type
  +TrackPoint? point
  +String? message
  +factory newPoint(TrackPoint point)
  +factory error(String message)
}

enum TrackPointEventType {
  newPoint
  error
}

' Связи
UserTrack --> TrackPoint
IUserTrackRepository --> UserTrack
IUserTrackRepository --> TrackPoint
LocationTrackingService --> TrackPoint
LocationTrackingService --> UserTrack
RealtimeTrackingService --> UserTrack
RealtimeTrackingService --> TrackPoint
RealtimeTrackingService --> IUserTrackRepository
ConnectionEvent --> ConnectionEventType
TrackPointEvent --> TrackPointEventType

@enduml
